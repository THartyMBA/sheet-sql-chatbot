# sheet_sql_chatbot.py
"""
LLM-Powered Q&A + SQL Runner on Google Sheets  📄💬📊
────────────────────────────────────────────────────────────────────────────
Type natural-language questions about any **PUBLIC** Google Sheet and get
back answers — along with the SQL that was auto-generated by a free
OpenRouter model and executed via DuckDB.

**POC limits**  
• Works only with *public-to-web* Sheets (no OAuth).  
• One table per sheet (first worksheet).  
• No joins or sub-queries for now.

Need SSO auth, multi-table joins, or caching? → drtomharty.com/bio
"""
# ────────────────────────────────── imports ───────────────────────────────
import os, requests, pandas as pd, duckdb, io
import streamlit as st

# ───────────────────────── OpenRouter helper ──────────────────────────────
API_KEY = st.secrets.get("OPENROUTER_API_KEY") or os.getenv("OPENROUTER_API_KEY") or ""
MODEL   = "mistralai/mistral-7b-instruct"  # free tier

def llm_to_sql(question, columns, table_name="data"):
    schema = ", ".join(f"{c}" for c in columns)
    system = (
        "You are a SQL translator. The target dialect is DuckDB (PostgreSQL-like). "
        f"The single table is named `{table_name}` with columns: {schema}. "
        "Return only a SELECT statement that answers the user's question."
    )
    url = "https://openrouter.ai/api/v1/chat/completions"
    headers = {
        "Authorization": f"Bearer {API_KEY}",
        "Content-Type": "application/json",
        "HTTP-Referer": "https://portfolio.example",
        "X-Title": "SheetSQLChatPOC",
    }
    body = {
        "model": MODEL,
        "messages": [
            { "role": "system", "content": system },
            { "role": "user",   "content": question }
        ],
        "temperature": 0,
    }
    r = requests.post(url, headers=headers, json=body, timeout=45)
    r.raise_for_status()
    sql = r.json()["choices"][0]["message"]["content"].strip()
    # remove markdown fencing if present
    return sql.strip("`").strip()

# ───────────────────────────── helpers ────────────────────────────────────
@st.cache_data(show_spinner=False)
def load_sheet(sheet_id, worksheet_gid=0):
    url = f"https://docs.google.com/spreadsheets/d/{sheet_id}/export?format=csv&id={sheet_id}&gid={worksheet_gid}"
    csv = requests.get(url, timeout=30).content
    return pd.read_csv(io.BytesIO(csv))

# ─────────────────────────────── UI ───────────────────────────────────────
st.set_page_config(page_title="Sheet Q&A SQL Bot", layout="wide")
st.title("📄💬 Google Sheet Q&A (SQL-via-LLM)")

st.info(
    "🔔 **Demo Notice**\n"
    "Public Sheets only • single worksheet • DuckDB in-memory. "
    "For enterprise-grade BI chat, [contact me](https://drtomharty.com/bio).",
    icon="💡",
)

sheet_url = st.text_input(
    "Paste a PUBLIC Google Sheet link (or just the Sheet ID)",
    placeholder="https://docs.google.com/spreadsheets/d/1abcDEF456...",
)
if not sheet_url:
    st.stop()

# extract Sheet ID
if "docs.google.com" in sheet_url:
    try:
        sheet_id = sheet_url.split("/d/")[1].split("/")[0]
    except IndexError:
        st.error("Could not parse Sheet ID.")
        st.stop()
else:
    sheet_id = sheet_url.strip()

with st.spinner("Loading sheet…"):
    try:
        df = load_sheet(sheet_id)
    except Exception as e:
        st.error(f"Error loading sheet: {e}")
        st.stop()

st.success(f"Loaded {df.shape[0]:,} rows × {df.shape[1]} cols")
st.dataframe(df.head())

# ─── chat interface ───────────────────────────────────────────────────────
st.subheader("Ask a question")
query = st.text_input("e.g., What's the average sales in 2024?")
if query and API_KEY == "":
    st.error("Add your OpenRouter API key to secrets.")
    st.stop()

if query:
    with st.spinner("Translating to SQL + running query…"):
        sql = llm_to_sql(query, df.columns.tolist())
        # run SQL in DuckDB
        con = duckdb.connect(database=":memory:")
        con.register("data", df)
        try:
            result_df = con.sql(sql).df()
        except Exception as e:
            st.error(f"SQL failed:\n{sql}\n\nError: {e}")
            st.stop()

    st.code(sql, language="sql")
    st.dataframe(result_df)

    # download
    st.download_button("⬇️ Download result CSV",
                       result_df.to_csv(index=False).encode(),
                       "query_result.csv",
                       "text/csv")
